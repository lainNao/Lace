ルールーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー
    ＜ブランチ＞
        main            //リリース用
        develop         //開発用
        feature/～      //機能用
        feature/any     //機能用（なんでもあり）

    ＜コミット＞
        ・なにもない時は「git commit -m "-"」でよい

    ＜ソース＞
        ・現状自動テストは無しの設計で。でも最終的には作りたい
            ・作る時はリポジトリのインターフェースとかも最終的に用意してDIとかもやる方向に変えたいとは思ってる（リポジトリのawaitどうする問題の後）

TODOーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー
    ＜重要（優先度高いorクリティカル）＞
        ■たぶん最初フォルダ作ってないとエラーになるから、カラムスペースやカラムのフォルダは無いなら自動生成するようにすること
            はい
        ■データに変更起こしたらサービスからリポジトリにいちいち保存かけていってたけどこれuseEffectまたはRecoilのatomのセッター部分でDBへの保存処理書けばそれらのコード全部いらなくなるかもしれない…
            ・バックエンドの考え方よりも楽できる部分があるかもしれない…
            ・これ実現したらアーキテクチャとしてまとめたいからメモっといて…
            ・でもこれトランザクションはやりづらい？逆にやりやすい？
        ■トランザクションやって…
            ・ファイルがDBで複数ファイルにまたがる更新のトランザクションは、まず対象ファイルのバックアップ作成してtry catchの中で更新してcatchされたらバックアップからリストア、そうでないならバックアップは削除みたいなことにするつもり…
                ・キャッチすらされずにPCやアプリケーションが落ちた場合はどうする…？起動時に「前回の状態を復元しますか？」と出してOKならバックアップをリストア、No選ばれたら一応壊れてるのを読み込む。例外出たら「データファイルが壊れています。最新のバックアップを復元します」で強制的に復元するか。（疲）
            ・これでどうにか整合性取れるか…
                ・ただ、リストアが間に合わないくらい高速であれこれやられたら破綻するな…これまた面倒な…これはどう対処したらいいのか…。loadingスピナー的なもので暫定対処していくしかないのかな…。いや、awaitやめればいいのか…なるほど。
                    ・あーでもリポジトリをレンダラープロセスでやってるから画面がフリーズしちゃうのか。メインプロセスに移すかな…。
                    ・awaitじゃなくす以外の方法は無いかな…。
                    ・いやでもawaitは結局使うしか無いじゃん（リポジトリをメインプロセスに移したとしても、そのメインプロセスを叩く時にawaitするでしょ）。いや、こっちのawaitは問題無いのか。ファイルいじりのawaitが危険なだけ？
                ・いやいやリポジトリはトランザクション中対象ファイルを全部一斉にロック＆終わったら解除するようにしたらいい。それでたぶん解決だ。
        ■データ消えないようにすること
            ・このアプリケーションは無慈悲にデータが突然消えるので、コアのAPIは本当によくテストされておく必要があると思う
                ・例えば変な操作をしてリポジトリに投げて保存が失敗するとDBまるごと消える？初期化される。（ソート順で無いインデックスを指定したらそうなった）。これはそうならないようにする必要がある。
            ・コアのAPI自体は正しくても変な構造のデータを送り込んだら消えるとかありそうなのでそこも防ぐ必要がある
            ・あとバックアップもちゃんと取るようにしたい
            ・これ、複数ファイル触るときの途中で落ちた時、特定ファイルだけが壊れたままになるだろうけど、その後に再起動してまた開いた時にその壊れたものを開くことになるじゃん。その対策どうすればいいんだ。
                ・読み込み不能ならその例外をキャッチすればいいだけだけど、特定ファイルだけきれいに編集されて再起動なったら駄目だよね。いやこれはコミットしないと反映されないようにすれば問題ないか。
                    ・コミットの仕組みは↑に書いた
        ■編集履歴機能
            ・ctrl + zである程度戻す機能がほしい。たぶん普通にcolumnSpacesの履歴を30個くらい前まで残しておけばいいだけなので後からでも実装できる。というかこの機能無いと怖くて使えない。
            ・ファイルシステムってゴミ箱から復元できるから安心感あるわけだし、戻る機能やバックアップがデフォで無いと使おうと絶対思えない。
        ■インストール不要化
            ・asarとかでインストール不要な形にパッケージングしたい
            ・その場合データの保存先パスもその実行ファイルが置いてある場所がデフォになるようにしたいところ
            ・インストール不要化したらなんか問題ある場合はインストール型にする。でもvscodeみたいに気軽にアップデートできる（できてるの？）ような感じにはしたい
        ■保存場所カスタマイズ機能
            ・ひとまずdocument配下にしてるけど
            ・これはインストール不要化を終えてからやる。
        ■自動アップデート
            ・ぐぐったらなんかやっぱり公式がいろいろかんたんにやれるよう用意してくれてるっぽい
                https://www.google.com/search?q=electron+check+for+updates&oq=electron+check+for+updates&aqs=chrome..69i57.3909j0j4&sourceid=chrome&ie=UTF-8
        ■普通起こらないはずの例外と、機能的に使ってる例外達を分けたい
            ・前者は「クラッシュ」と判定して、それが起こる前のDBを完全にバックアップし、一度アプリケーションを使用不能にする。なぜならそれ以上データ壊すの防ぎたいから。
                ・で、そのクラッシュは自分のサーバに自動送信させたい。DBとしてfirebaseの無料枠使おうかな…？うーん権限判定とかできるかな。
                    ・もちろんその情報送信するかどうかはユーザーに許可取って設定させる。
            ・後者は普通にアプリケーション内のgotoみたいな用途で使いたい。
            ・後者の方は自前の例外の型を作ってそれ使えば良いと思う。それだけを機能的な例外として認識し、その他はクラッシュとして扱うかな…？
    ＜他（リリース前には必ず）＞
        ■最後の最後再の確認したり決めたりしたらいいや
            ・スクロールバーとか出たら崩れないか
            ・テキストの大きさとか軽微なスタイルとかの見た目を最後に確認。例えば文字とか結構小さくて良いと思う。slackかなり小さいし
            ・ロゴやタイトル
                ・今のホームアイコンのところ、ロゴにすればいいのでは。で、設定アイコンのところ現状何も機能無いから非表示で。
            ・初期データはもうちょっと分かりやすいサンプルに変える。またはいらない。
        ■見た目
            ・中央ペインの再生ボタンはreact-uwpとかを使う？
            ・メニューバーの中央には現在選択状態のカラムスペース名を表示したい。「カラムスペース名 - アプリ名」的な。完全にVSCodeになっちゃうからもう少しslackも混ぜるか、。
        ■機能
            ・最初のDB初期化部分とかまだ実装してないよね。今の勝手にやるやつは廃止だから。
            ・メニューバーどうする…？作って。（以下英語でやってるけどメニューアイテムの言語も多言語化して）
                Setting
                    ・language - 日本語、English
                Help
                    ・説明ページを見る（説明するreadmeへのリンク）
                    ・about（モーダルを出して説明文を書く。というか諸情報をはpackage.jsonから動的に読み込んで表示するだけでいい）
                    ・check for updates（アップデートをチェックして、あるなら「v～へアップデートしますか？」とか出してOKならアップデートを走らせる）
                    ・問い合わせフォーム（googleフォームへのリンクがあるページへのリンク。readmeの最下部あたりとか）
            ・フッターどうにかする
    		・アップデートチェック機能
            ・コンテキストメニューでカット、コピー、ペースト　https://qiita.com/indometacin/items/0a436338165dc8b76ec4#%E3%82%B3%E3%83%B3%E3%83%86%E3%82%AD%E3%82%B9%E3%83%88%E3%83%A1%E3%83%8B%E3%83%A5%E3%83%BC%E3%81%A7%E3%82%AB%E3%83%83%E3%83%88%E3%82%B3%E3%83%94%E3%83%BC%E3%83%9A%E3%83%BC%E3%82%B9%E3%83%88
            ・多言語化
            ・設定画面
                - データの保存ディレクトリパス（パス選択ウィンドウで決める。決めたら、既存のDBはそこにコピーする。消せないモーダルに進捗率を出す。完了したらOKさせる）
                - 言語（select。onchangeで適用）
        ■ソース
            ・モデルのミュータブル、イミュータブルどうするか問題　https://twitter.com/masuda220/status/1392531139756056577
        ■若干の機能的な残作業
            ・カラムやカラムスペースを消したら、紐付いてるファイルも消す。ただしそれはウィンドウを閉じる時とか次回開く時とかでいい。または明示的にクリーンアップのメニューを用意する。結果整合性的な。または関連ファイルを一気に削除しちゃう
				・これ逆に一緒に消しちゃうと、トランザクションでは戻せないから、やっぱり同時にやらずにクリーンアップ的なメニューを用意するのがいいと思う。たぶんこれ普通のwebアプリでも同じことすると思う、バッチ的な。知らんけど。
					・ただ、それなら「deleted_columnspaces」的なテーブルに入れておいてそこをピンポイントで走査するようにしないと全体を走査するのは処理効率下がるわ。でもそうなると大変なのでそこまでやるのはバージョンアップ対応でいいかも。クリーンアップ自体は最初から用意したい。
				・このクリーンアップは、設定画面に「DB容量最適化」的な項目を用意して、その説明になんでこの項目があるのか書いて、「最適化を行う」ボタンを用意すればいい。一応クリックしたら確認ウィンドウ出してOKなら行う。
            ・UUIDv4じゃなく、日時ありのやつにする。基本絶対かぶらないやつ。またはもうUUIDv4の後ろにタイムスタンプ追記でもする。不安なので。
            ・buildすると、DBやユーザデータ置き場のフォルダとか消えるので、DBは「無い場合は作る」という動作をするようにすること。
                ・ビルドするとパスが変わったりすることがありそうなので、やっぱり絶対パスで試す。絶対パスでやると逆にうまくいかなくなる場合もありそうなので、試しながらやる。
            ・一応過去のDBはコピーして残しておくこと（設定でどんくらい残すか決められるようにする）
            ・各種モデルのAPI、駄目なのに例外も出ないし戻値も無い感じだと成功しましたって出るから紛らわしいのでそこらへんのモデルのAPIどうするか考える。
                ・再帰してるから変に例外出すと止まっちゃって面倒だから例外出せないんだよな気軽に…。戻値方式でやるか…でもどう統一するか…
                ・これはテスト実装と同時でいい気がする
        ■他
            ・vercelかfirebaseとかにLP作るかな　説明とかもそこでやったほうがいいかも　DLリンクからはgithubのリリースページに飛ばすようにして
            ・ライセンスを明記したい。何にするのかも決める。オープンソースには一応する。
            ・ソース内のTODOを基本的に片付ける（マークダウンのプレビューとか含め）
            ・いろいろ参考にチューニング
                https://qiita.com/indometacin/items/0a436338165dc8b76ec4
            ・大量データの性能テスト、UI崩れのテストをする。めんどいから動作確認すらしてない。
                ・「これは駄目だな。カス」ってなったらアーキテクチャごと変えるのも全然考える。なんせ元々自分がほしいものだから諦められない
    ＜他（おいおい）＞
        ■UI/UX
            ・カラムの横幅を変えられるやつを導入したい resizable panel react とか split pane とかググればそれっぽいの出てくる　react-split-paneがシンプルでよい？re-resizableの方が？
                ・paneのリサイズは以下がマージされたら対応したい
                    https://github.com/moritzmhmk/react-split-pane/commit/a330d6da93091e487efd87a2dd19cc41f22907c8
            ・slackみたいにカーソルがエクスプローラー側にある時だけエクスプローラー側にスクロールバー出したい
            ・画面遷移時にプログレスバーを出す
            ・文字を確定させずにsubmitしたらIMEのあれが残るやつ、compositionstart, compositionupdate and compositionendをうまく使ってどうにか対処したい
            ・テーマどうするか問題
            ・disabledされてるUIパーツをタップやホバーした時になぜdisabledされているのかの理由を書いてほしい
            ・リンクをデフォルトブラウザで開く　https://qiita.com/indometacin/items/0a436338165dc8b76ec4#%E3%83%AA%E3%83%B3%E3%82%AF%E3%82%92%E3%83%87%E3%83%95%E3%82%A9%E3%83%AB%E3%83%88%E3%83%96%E3%83%A9%E3%82%A6%E3%82%B6%E3%81%A7%E9%96%8B%E3%81%8F
            ・nativeTheme.shouldUseDarkColors　とかでシステムの設定を反映させるかどうか（余裕出たらやるやつ）
            ・スクロールバーを出すのがそのdivにマウスが乗ったときのみにするのもライブラリあるっぽい
                https://openbase.com/categories/js/recently-updated-react-scroll-bar-libraries?orderBy=RECENTLY_UPDATED&
            ・せっかくだからフォントをウェブっぽくないちゃんとしたのに変えたいところ。いちいちhttpリクエスト発生するわけじゃないしさ。ただし絵文字とかも全対応させたいのでそこらへんちゃんとしてるやつのみかな。
            ・ショートカットキーとか
        ■機能
            ・ドメインイベントを作るか考える。やり方的にはとりあえずかんたんにstaticフィールドに配列でオブザーバー達のクラス名とメソッド名を入れて、それを特定タイミングで自動newして発火するようにする感じでいいのかなと思う。いや、staticならnewもいらないし。
                ・でもこれ、重くならないかな？うーん。例えば末端のColumnの削除系メソッドにドメインイベントを仕込んだら、カラムが消されることなんて大量にあるじゃん。それを毎度発火するより、もっと上のColumnSpaceあたりで発火したいところだよね。
                    ・それは単に選択の問題かな。となるとむしろ今各種メソッドをColumnSpaces起点にやってるからそこにつっこめばいいかな。
                ・あとこれは各種メソッドをリファクタリングした後でやりたい。
            ・いろいろログを入れたい（特にエラーログ）。そうなるとドメインバリデーションの例外はスルーするようにしないといけないな。自前のを作るか。
            ・カラムスペースのリネーム
            ・自動テストを入れてリファクタしやすくする
            ・カラム消したらそれにまつわる表示設定も消されるけど、いずれ消されないようにしたい。今はとりあえず削除で
            ・CSV取り込み、出力の機能がほしい（セルのリレーションについてはidで紐付けてもらう感じで。で、同じカラムにリレーション作ってたりしたらエラーとするなどはしたい。ただこれそれなりに大変そう）
                ・これ、このアプリケーション専用のデータ構造から一般的なデータ構造で関連データを見れるようにしたい要望あるだろうからあるとよいと思う
            ・ダークモード、ライトモード、しゃれおつモードを用意する（最終的にはユーザーが自分で設定できるようにする）
            ・v2を作る時、v1からexportできるようにしたい（これ、csvエクスポートとcsvインポートでまかなえるかも）
            ・画面サイズを変更できる（ミニプレイヤーモード、普通モード）
                https://www.it-swarm-ja.tech/ja/electron/electron%E3%81%A7%E3%82%A6%E3%82%A3%E3%83%B3%E3%83%89%E3%82%A6%E3%82%B5%E3%82%A4%E3%82%BA%E3%82%92%E5%A4%89%E6%9B%B4%E3%81%99%E3%82%8B/833870529/
        ■ソース
            ・カラムのソート処理、それ用のコンポーネントに任せたほうがよかったかも…（探してもどれも惜しくて、優先度低い）
            ・正規化されたDBと表示用JSONを分けるのもあり
            ・ファイルに触るのはメインプロセス側だけにしたほうがいいかもしれない…　https://zenn.dev/forest1040/articles/7f6794d8651fd4
            ・「remote」が非推奨になってるので使わないコードに変更する。いや、できるならば。
            ・モーダルが連なると、コールバックをコントローラーから持ってくるかモーダル内で作るかの判断が出てくるけど、これどうするか問題ある。
                ・モーダル内はモーダル内でコントローラー作らずにやっていい気がする。
                ・それか、モーダルを1画面を換算し、一つにつき一つコントローラーを作るなど。多分こっちのほうがいい気がする。コントローラーにも大本のコントローラーと末端のコントローラーあって責務分けになるし。
            ・さすがに読み込み時や書き出し時に無駄なので、カラムスペースごとにdbファイルを分けたいところ…でも階層立ってるからな…
                ・別カラムスペースと連動する方式を作りたい場合、その対象カラムスペースのDBを依存先として別途読み込む方式にする（つまり、カラムスペースのjsonのところに依存カラムスペースUUIDの配列的なものを用意して、そこにあるのも読み込むなど）

メモーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー
    ＜概念＞
        カラムスペースス         //複数のカラムスペースをまとめるオブジェクト
        カラムスペース           //全カラムをまとめるオブジェクト
        カラム                  //カラム
        セル                    //カラムの中のセル
        リレイテッドセル         //セルに関連づけられたセル

    ＜設定画面＞
        ・global_settings.jsonをいじるとする。設定画面は単純にラベルとinputのテーブルにしてCRUDするだけの見た目でとりあえずいいかな
            ■いじらせないけど存在するキー
                majorVersion: メジャーバージョン番号         //メジャーバージョンが違った時、マイグレーションする用に使う（これはユーザーには更新させない）。メジャーバージョン変わってもDBの構造変わらないならマイグレーションは不要
            ■いじれるキー
                autoReport: 真偽値                          //起きちゃいけない例外がキャッチされた時に自動でサーバーに情報を送るか。いらんかなこんなの。うーんまあ考えておく
        ・GlobalSettingsモデル、一応キーに型つけられるかも

    ＜音声データ、基本的には再生したら再生中のやつは一時停止したい＞
        ・音声セル管理モーダルでは実装したので他のところでも基本的にやること

    ＜リレーション、カラムスペースの削除に追従する必要あるので留意＞
       ・例えば以下はリレーションも適宜削除している
            removeColumnSpaceUsecase
            removeColumnUsecase
        ・カラムスペースを削除する時はカラムスペースごとリレーション削除すればいいので楽
        ・カラムを削除する時はtoとfromで別の削除することになるが、removeRelationOfColumnを呼べばよいようにした
        ・セルを削除する時はまた別途必要になってくるので、その時やる
        ・これ、ドメインイベントで対応しても良かったのかなと思う。頭が追いつかなかったけど。書き換えるなら書き換えて。

    ＜RelatedCells登録時の留意＞
        ・いずれのカラム両方にもデータ入れる必要ある（Aカラムのセル1とBカラムのセル2を関連付けた時、Aカラムのセル1の方にもBカラムのセル2の方にもRelatedCellに登録する必要ある。でないとたぶん表示時に計算量が増えすぎる）

    ＜大まかな表示のイメージ＞
        以下の3階層が基本的な考え
        ―――――――――――――――――――――――――――――――
        ・ソート列
            ・メイン表示列
                ・メイン表示列が持つ関連カラムと紐づくセル達
        ―――――――――――――――――――――――――――――――
        ソート列は複数指定可能

    ＜Boolean、Select、Radioとかの複数の値を取りうるカラムは、あってもいいけど消すことにした＞
        ・なぜなら同じことはテキストカラムで全部できるから
        ・Boolean、Select、Radioとかは要するに「セルが一つ」で、関連づけたそのカラムのその一つのセルに対して、関連づけた側のセルの方がその選択値を保持する必要あるんだよね。だからまずその点で一個複雑性が出る
        ・で、例えばselectって「複数の中からいずれかを選択」ってことだけど、それを一つだけ選択なのかcomboboxみたいに複数選択なのかとか考えてたら「そもそもそれってテキストカラムにして一つまたは複数関連づけてもらえばいいやつなんじゃないの？」と気づいてしまった
        ・複雑性が出ても本質的ならばいいんだけど、今回に関してはこれをそのままにしておくとそもそも想定していたデータ構造じゃなくてなんか二重のメタ構造ができてしまうから、それは微妙かなと思った
        ・代わりに、カラムごとに「表示タイプ」みたいなものを持たせて、表示する時に「タグ風に表示」「ラジオボタン的に表示」「セレクトボックス風に表示」とかできるようにしたらいいのかなとは思う

    ＜コード進行カラムの構想＞
        ・「コード進行」（＋「の断片」かな）カラムとか作れるようにして、それは「4M-3m7」とか登録したら「4M-3m」とか「4M6-3m9」とかも設定で非ケースセンシティブな検索もできるような感じのこともしたいところ…　後でコード進行単位でも検索したいしね。
            ・そうなるとソート順ペインは「1」から順になるだろうし、かつその右側のサブソート順はどうなるんだろう？選べるようにしたいよね（7thとM7とかテンションでも分けたいし、かと言って始まりだけじゃなく「4M7-3m7」と「4-3m」も同列に扱いたいし…）
                ・これはどうしようか…まあこれは出来終わってから追加でもいいんだけどシンプルにほしいところ…
        ・コード進行カラムは、「コード進行＋補足説明」にしたほうがいい。でコード進行自体は空欄でよいとしたほうがよい（具体的なコード進行の番号よりもセクションの流れが大事なのもあるので）

    ＜リズム表記カラムの構想＞
        ・コード進行カラムも作るならリズム表記のカラムも作る（○と●と|で表現してたやつ）

    ＜音楽ファイルや動画ファイルは切り抜きをして取り込みができる機能の構想＞
        ・動画ファイルやサウンドファイルは取り込む時に秒数～秒数の指定をして一部だけ取り込みとか簡単にできればよりよい

    ＜セルのポリモーフィズムについて＞
        ・要するにenumをキーに出し分けてくれるファクトリーを作ればいいだけ
        ・インスタンスのファクトリー、ビューのファクトリー、表示文字列のファクトリーをそれぞれ、ポリモーフィズムしたいやつの共有のEnumをキーにして作ればいい
        ・そのため、他のポリモーフィズムしたいところも同じく同じEnumをキーに各層でのファクトリーを作ればいいだけ
            ・別にファクトリーはクラス化する必要はないけど、クラスにまとめてしまってもいいかもしれない。

    ＜「～s」類のモデルはIDを持たない単なるファーストクラスコレクションなので適当にミュータブルにしている＞
        ・既にしていたメソッドをイミュータブルにする手間も感じた
        ・ただまあ必要ならどうにかすることも考える

    ＜表示/非表示フラグのuseState管理だとコスト高そうな部分は、hiddenクラスの削除/追加でやりくりしている＞
        ・はい

    ＜簡単なウィンドウの状態保存にはlocalStorageを使っている＞
        ・一応repository通したほうが良いかな…ソース的に…
        ・ここは後に必要ならば

    ＜コンテキストメニューやダイアログにおいてremoteを使っている＞
        ・コンテキストメニュークリックで動的にdialog出してその結果を受け取りたいんだけど、それがremote使わないと現状やり方わからなかったから。
            ・一応単純なことしかしないコンテキストメニューを出すのはメインプロセスのみでできるけど
        ・ただ「remote」はAPIとして廃止されてしまっているっぽいので、別のremoteのユーザーランドのやつとかに一応移行しておく必要がある。ただ試したけどうまくいかなかったのでまた…
            →いやこれ、invokeでできそう。
                ・invokeでメインプロセスに作ったイベントハンドラを叩く。
                ・そのイベントハンドラ内でダイアログを開かせる。ダイアログの表示文字列はレンダラープロセスから送信できるはず
                ・ダイアログの戻値はメインプロセスで取得し、取得したらメインプロセスからレンダラープロセスへsendする（それができるイベントの仕組みがあるはず）
                ・でそのsendされたのをレンダラープロセスに作ったイベントハンドラで受け取る（そのイベントハンドラはrecoilがアクセスできる範囲で作られる必要があるけどたぶんできる）

                    レンダラ→　メインでダイアログ開く
                                ↓
                    レンダラ  ←ダイアログの戻値
                    ↓
                    戻値によってrecoilの処理をする

                ・なんと面倒な…
        ・だからまあ今の所放置で

    ＜データ構造について＞
        ■カラムスペース集約（カラムスペースやその配下のセルやカラムなどを保持）
            [
                {
                    id: UUID,                   //カラムスペースのUUID
                    name: text,                    //カラムスペース名
                    columns: {},
                    childColumnSpaces: [           //子カラムスペース達
                        {
                            id: UUID,                      //id
                            name: text,                    //カラムスペース名
                            columns: [                     //カラムの全データ
                                {
                                    id: UUID,                //カラムのUUID
                                    name: string,            //カラム名
                                    type: enum,              //カラムのタイプ
                                    cells: [                 //自カラムが持つデータ達
                                        各種データ             //自カラムデータのUUIDとデータ本体（実データの形式は、typeのenumによって変わる）
                                        ...

                                        /*file類（Sound、Video、Image）の場合*/（音楽はアーティスト名もいるかと思ったけど、崩れるから辞めた。自分は不要。その代わり随所で楽に試聴できるようにしたいところではある）
                                        {
                                            name: text,              //メディアのファイル名
                                            dispname: text,          //表示用の別名
                                            basename: text,          //ファイル名（拡張子あり）
                                            extname: text,           //拡張子
                                            path: text,              //メディアへのpath
                                        }

                                        /*Textの場合*/
                                        {
                                            text: string,
                                        }

                                        /*Markdownの場合*/
                                        {
                                            title: string,
                                            text: string,
                                        }
                                    ],
                                },
                                ...
                            ]
                            childColumnSpaces: [],      //columnsにデータがある場合、ここが空である必要がある（ちょっと汚い設計な雰囲気感じてるけどもう無理、。実装的には不整合は防げる気はしてるから）
                        },
                        ...
                    ]
                },
                ...
            ]

        ■関連セル集約（ルートだけモデル化し、その他はしてない…。がんばって）
            // RelatedCells
            {
                // RelatedCellsColumnSpaceIndicator
                カラムスペースのUUID: {

                    // RelatedCellsColumnIndicator
                    カラムのUUID: {

                        // RelatedCellsCellIndicator
                        //このセルの関連セル達を保存　（留意：関連元セルには「カラムID」の情報は持たない。なぜならカラムスペース直下にキーを作ればカラムからたどる不要だから）
                        セルのUUID: {

                            // RelatedCellsTargetColumnIndicator
                            // そのセルはこのカラムIDのこのセル達と関連している
                            カラムID: [セルID, セルID,...],
                            ...
                        },
                        ..

                    }
                    ...

                },
                ...
            }

        ■表示形式集約（ソート形式や右ペインの表示形式を保持する）

            // DisplaySettings
            {
                DisplaySettings.children
                // カラムスペースごとの表示形式の保存
                カラムスペースのUUID: [

                    // DisplaySetting
                    {
                        // 表示形式ID
                        id: UUID,

                        // 表示設定名
                        name: "フレーズ別要素、とかの名前",

                        //ソートに使うカラム（降順昇順とかのサブパターンもあるだろうけどどうする…？後で…）
                        sortColumns: [カラムID, カラムID, ... ],

                        // メイン表示する中央カラム
                        mainColumn: カラムID,

                        // 関連セルの表示形式
                        relatedCellsDisplaySetting: {
                            // 表示形式
                            type: RelatedCellsDisplayType,      //VList（普通の箇条書き）、VListDot（●を頭につける箇条書き）、VListNum（数字を頭につける箇条書き）、HListSeparator（「、」とかで区切る横書き）、HListTag（タグ風の角丸マークで横書き）
                                                                //CustomList（任意の表示。詳しくは、自分の創作技法集の表示に合わせる感じなのでそっち参照。簡単）

                            // DisplayDetail.CustomList | DisplayDetail.HListSeparator
                            // type別の詳細設定。現状CustomListの場合とHListSeparatorの場合だけで、それ以外の場合はnull
                            typeDetails: {

                                /* HListSeparatorの場合 */
                                separator: "、とかのセパレータ文字"



                                /* CustomListの場合 */

                                // タイトル（CustomListじゃない場合、カラム名がタイトルとして使われる）
                                title: "曲例、とか",

                                // カラム達の設定
                                columns: [
                                    {
                                        columnId: カラムID,

                                        prefix: "つけたい前置文字。nullable",

                                        suffix: "つけたい後置文字。nullable",

                                        // このカラムの前に改行かつインデントを入れるか（何言ってるかわからない場合自分の創作技法集の表示参照）
                                        needBreakLine: 真偽値,

                                    },
                                    ...
                                ]

                            }
                        },

                    },
                    ...

                ],
                ...
            }

        ■グローバル設定集約
            {
                // 初めての起動などで、まだ初期設定をしてないか（各種DBの自動作成など行う。いやDBの自動作成はファイルのあるなしで判定したほうがよさそう）
                "hasInitialized": 真偽値,

                //
            }


■サンプルデータ
    ＜＞
    ＜＞
    ＜display_settings.json＞
        {
            "カラムスペースのUUID": [
                {
                "id": "UUID",
                "name": "フレーズ別要素、とかの名前",
                "sortColumns": [111,222],
                "mainColumn": "3333",

                "relatedCellsDisplaySetting": [
                    {
                    "type": "CustomList",
                    "typeDetails": {
                        "title": "曲例、とか",
                        "columns": [
                        {
                            "columnId": "カラムID",
                            "prefix": "つけたい前置文字。nullable",
                            "suffix": "つけたい後置文字。nullable",
                            "needBreakLine": false
                        }
                        ]
                    }
                    }
                ]
                }
            ]
        }


