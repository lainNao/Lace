ルールーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー
    ＜ブランチ＞
        main            //リリース用
        develop         //開発用
        feature/～      //機能用
        feature/any     //機能用（なんでもあり）

    ＜コミット＞
        ・なにもない時は「git commit -m "-"」でよい

    ＜ソース＞
        ・現状自動テストは無しの設計で。でも最終的には作りたい
            ・作る時はリポジトリのインターフェースとかも最終的に用意してDIとかもやる方向に変えたいとは思ってる（リポジトリのawaitどうする問題の後）

v1版の新しいRDB版のデータ構造ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー
    ＜RDB案＞
        ■説明
            ・まず、完全にリポジトリを変えたほうがいい。環境も新しくする。
                Next.jsじゃなく素のReactでいい。
                typescriptは最初からstrictモードで。
                今の「TODO」となってるところは全部最初からこなす。例えばインターフェース切るとか単体テストできるとかDIするとか、見た目とか。
            ・ファイルシステムは、普通に「ネストしたコメント欄」の表現をすればRDBでも再現できる
                ・例えば「記事」と「ネストしたコメント」ってのも別にORMで普通に再現できる
                    テーブルは「postsテーブル」「commentsテーブル」など
                    Postクラスがcommentsフィールド（配列）を持つ
                ・しいて言えば留意なのは、linuxのファイルシステムのように「/」も「/usr/a.txt」も同じくファイルとして扱う
            ・コメント同士の関連も、単に中間テーブルの概念で行ける
                テーブルはrelated_comments的な
            ・今までとの違い
                今までのカラムスペースとセルは「ファイル」という概念に統一
                カラムという概念はいらないので削除。なのでちょっと仕様も変わるはず。完全に新しく作り直したほうがいいと思う、strictモードで、テストも込みで、レイヤー分けも完璧に、ゆっくり…。

        ■テーブル
            files（ここはネストするので、そのネストのアーキテクチャの選択をまた後でして、それをカラム構造にも反映。以下は最も簡単なイメージの例）
                id, type（enum）, parent_file_id
            file_datas
                id, data（json）
            related_files（これ、fromとtoを逆にしたレコードも作って非正規化するか、file_idが若い方をfromにするというルールにするかとか、まだ考える事が必要）
                id, from_file_id, to_file_id
            他
                display_settings    //表示設定テーブル
                    id, file_id, ～～～（sortColumnsとか、関連カラムの表示設定とか、別のデータテーブル作っていいかな）
                settings            //設定を入れるテーブル

        ■（さらに検討案）表示用に非正規化したjsonをその都度生成するアーキテクチャ
            ・RDBをマスターにし、表示用のJSONファイルを生成するアーキテクチャ。
            ・そうすれば、今やっているような「表示用のDTOを生成するトランスフォーマー」は表示切り替えのたびに発火するのでなく、データ変更の度に1度ずつ発火するようになり、タイミングが変わる。
                ・かつ、一度データを一通り揃えてしまったら、もうそのトランスフォーマーは回す必要が無くなり、表示がメインならば低コストになる。
            ・これはいいと思う。
                ・生成したjsonをどこに保存するかは、ファイルとかじゃなく普通にsqliteのjsonカラムか、普通にlocalStorageか、普通になんらかのnosqlでいいと思う。
                    ・それをどれ選択するかはもはやどれでもいいかもしれない。でもより妥当かつ、よりアンチパターンアンチパターン言われづらいものはあると思う。
                        ・ファイルシステムは扱うのが面倒なのでsqliteやnosqlの方が楽だと思う。たぶんsqliteが一番楽な気がする。nosqlは逆になんでここまで使われないんだろう。どう比較したらいいんだろう。もうちょっと考えて。

        ■他
            ＜集約という考えについて＞
                ・集約というイメージを拡大解釈してたようだ
                    ・例えば「記事集約」なら1記事を扱うのが本来であり、自分はそれを「全記事集約」みたいなイメージが正しいと考えていたようだ
                ・実際には「記事集約」と「記事リポジトリ」で1つのidの記事のみを扱っていいっぽい。なぜならそういうサンプルが見つかるから。
                    ・で、リポジトリのsave(記事インスタンス)を入れたら一つの記事のみが上書きされるイメージ。それでいいっぽい。
                ・それなら↑の設計だとしても「file」集約とか「related_file」集約を作ればいいよね。
                ・今回集約の大きさを間違ったのは、シンプルに集約というものを大きく考えすぎていたことが大きい。
                    ・あとはあまりにもデータ構造がネストしてて複雑だったから。

    ＜NoSQL案＞
        ・別にNoSQLでもいいと思うんだよな。例あるし
            https://www.baeldung.com/spring-persisting-ddd-aggregates
        ・キーバリュー型だとして、キーをIDにするだけ。で中のデータ構造自体は今までと似た感じにできるし実装もほぼ似た感じになる。
            ・これでも問題無い気がする。逆にこれのいったい何が問題なのか。json構造であることはアンチパターンではないはず。

    ＜Graph型のNoSQL案＞
        ・もし組み込めるなら組み込んだ方が本筋な気がする
        ・特に「関係している」とかは普通に表現できるし
        ・ただ、そこまで優位性は無いのでRDBでやる安心感は優先度高い

    ＜何を採用するか＞
        ■基準：設計的妥当性
            ・いずれも妥当な場合、ここに差異は無い
            ・ただ「基本的にはRDBで正規化し、表示用jsonに非正規化は別途やる」とした方がNoSQL経験が無い人にアンチパターンアンチパターンと勘違いされないとは思う
            ・キャッシュがうまく表示アプリケーション側でできるならば、または表示用の非正規化したjsonをその都度新しくファイルとして生成するアーキテクチャにするなら、DBを何使うかは「より正規化ができる方」が正しいとしていいと思う。
        ■基準：パフォーマンス要件
            ・例えば1万件のデータを登録しても使えるようにしたいという要件がある場合、どれがより耐えられるか
            ・jsonへの詰替が不要な点でNoSQL型の方が速いかもしれない。ただ、今と同じように非正規化して扱うかもしれない
                ・ただ非正規化と言っても、今の構造もデータ重複はほぼ起こっておらず、しいて言えばRelatedCells内であえて二重データ登録をしているところか。でもそれ、Graph系のDBを使わないとfromとtoの表現しかできなくておかしい気がするんだよな。Graph系のDB使わないならこの二重保存はそこまでおかしくない気がするんだけどなどうなんだろう。
        ■基準：周りがどう思うか
            ・このパフォーマンスがクリティカルなアプリケーションのデータの持ち方は誰かに相談してみたいところ。
        ■現状の結論
            ・正規化されたDBは、NoSQLでなくsqliteにする。なぜなら以下のように非正規化されたjsonをその都度生成するようにするから。
            ・非正規化された表示用jsonの生成をRDBへの変更が加わる度に行い、それを表示に使う
                ・どこに保存しておくかは、sqliteかnosqlなど。ファイルは直接API触るのが面倒なので避ける。
                ・生成タイミングは以下いずれかが考えられる。
                    ・「常に、RDBに変更が加えられたら毎度リアルタイムで再生成する」
                    ・「表示する際に初めて、生成されてないならして表示して静止したものは保存」かつ「現在表示されているものに変更加えたらその場で再生成」
                ・生成内容のイメージは、むしろ前自分が作っていた静的サイトを参考にしてほしい。右ペインも左ペインも、onmouseしたら生成するんじゃなくて既にjsonの内容に含まれているので表示するだけなイメージ。
            ・大体これが暫定で。でまたシミュレーションしたい。うまく行きそうな気がするけど懸念もあげつらいたい色々。
        ■懸念
            ・いろいろ上げたい。で全部解消してから進んで欲しい。
            ・パフォーマンスの目安が立たないので先に立ててからやってほしい
            ・全アーキテクチャを細部まで詳細設計して欲しい。じゃないとまた失敗する可能性がある。
            ・全技術を全イメージしてほしい。じゃないと安心できない。
            ・レンダラプロセスとmainプロセスは普通に使い分ける。考え方としてはサーバーとクライアントでいい。rest apiよかgraphqlみたいなイメージでやり取りしてほしい。
                ・で、完全にうまく分離できるのか。remoteを使ってるところを全部mainに移せるか調べる。
                ・というか、今まではインスタンスまるごと送りたかったり、処理を送りたかったからレンダラプロセスからremote呼んでたけど、これってサーバとクライアントでインスタンスそのまま送ってるようなもので、本来は文字列でやり取りすべきだったと思う
                    ・というわけでほんとにサーバー/クライアントの関係だと思ってやり取りするしかない。仮にメインプロセスにインスタンスを送りたくなった場合、そうじゃなく、IDのみ送って、メインプロセス側にあるリポジトリでfindするようにするなどして使う方がいいと思う。
                ・でも関数を送りたいとかができなくなるから、動的に処理を決めることができなくなる。それの対応は考えて…

TODOーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー
    ＜他（リリース前には必ず）＞
        ■最後の最後再の確認したり決めたりしたらいいや
            ・初期データはもうちょっと分かりやすいサンプルに変える。またはいらない。
        ■他
            ・nextronから普通にelectronに移行したい。エラー画面が困るので。でもとりあえずバウンダリで防いどいたからいいかな？
            ・エラー起きたらエラー用のログファイルに書き出す。で、後で任意でエラー情報をサーバーに送信させる。バージョン情報含め。
            ・ソース内のTODOを基本的に片付ける
            ・初期化時にDBの場所がlocalStorageにあるものから変わらないな。別にいいんだけど、もしその場所ごと消え去ってるならエラー出るだろうから、フォルダ無いなら作るような処理になってるか確認したほうがいい。なってるならいい。
    ＜他（おいおい）＞
        ■パフォーマンス
            ・リレーション管理モーダルがけっこうパフォーマンス気になるかも。高速化とか諸々はいずれにせよsqliteにしてからの比較になるだろうけど留意として。
        ■疑問
            ・開発時、テスト時、自分で利用時のDBがまさかの同じのを使う形になってる。自分で使えないじゃん。そこらへん環境によってDB変えたい（ついでにsqliteに行くか）
                ・今はファイルになってるからいちいちまたファイルを面倒見るシステムにするのだるいんだよね。まだ「test/」的なパス追加するだけでいいなら分かるけど変にバグりうるし。
                ・いや、気のせい？というか最初だけ？（documents配下がデフォなので、最初は絶対かぶる？）
                    ・変えれば普通に別の場所になる？もしそうなら、開発をする人はとにかく「かぶらない場所に本番インストールしたやつのデータ保存先ディレクトリを設定する」でOKかも。
            ・localStorageに依存しているのでリポジトリが関わるテストできない件。どうにかしたい。
                ・RenderingProcessStorageというインターフェース作ってそこに押し込もう
                    ・でもDIどうする…？いいかひとまず中でif分岐しちゃえ…いや、関数で分岐するか…引数はNODE_ENVで
                ・保存場所は、DBで言えば接続文字列なのでnewする時に外部から注入したほうが良さげだと思う
                    ・ただ、次変えるときはsqliteに乗り換えるかなとは思う。
        ■UI/UX
            ・マークダウンのプレビューの文字サイズを小さくしたい
            ・モーダルだけ文字がでかいので小さくする
            ・カラムスペース作成のinput、esc押したら消せるようにしたい
            ・テキストの大きさとか軽微なスタイルとかの見た目を最後に確認。例えば文字とか結構小さくて良いと思う。slackかなり小さいし
                ・なんか全体的に色どうにかする
                ・ちょっとフォーム関係の文字サイズだけ異様にでかくない？
            ・補足ペインでツールチップ出してる間のタグの色変えたい
            ・補足ペインをawaitにしてクルクル出したい。どうすればいいんだ。計算をawaitなコントローラーでやって、propsとして最終レンダリングするように変えればよさそう。
                ・そしたら無限スクロールも使えるし、メインペインも同じようにしたらよさそう。なるほど。
                    ・いや、コンポーネント内でも処理できそう。コンポーネント内だけでawaitして、まだ計算終わってないときはクルクル出すとかできるならそっちのほうがいいはず。
            ・メインセルをctrl + fで検索したい
            ・selectedColumnSpaceIdもlocalStorageに保存して再起動時に再生できるようにするか。いやこれは選択性でいいかも
            ・DB移動のモーダル、なんか見た目チラ見できたけど変なので直したいところ
            ・ディレクトリのパスとかもバリューオブジェクトにしたほうがいいのでは
            ・メインカラムを右クリするメニュー
                関連セル表示を固定        //関連セル表示を固定する（かつずっとonmouse的な色にしておく）
                -----
                編集                     //セル編集する（テキスト、マークダウンのみ）
                リネーム                 //リネーム（メディア類）
                関連セル管理              //関連セル管理モーダルを開く
            ・設定画面とメニューバーのどこかにミュートモードのトグルをつける（特に音声データが基本的に勝手に再生始まるので職場だとミスりうるため）
                ・全audioとvideoにmuted={そのモードの真偽値}を入れるようにすればできそう
            ・中央ペインのセルとかを右クリしても直接編集とかリレーション管理とかできるようにしたいところ
            ・videoやaudioのlazy loadとかできるならしたいところ、調べるのも後においておいて今はスルー
            ・audioのプレイ状態はrecoilレベルのグローバル管理したほうがよかったかも…
            ・detailsでトグルする矢印をカスタマイズできるっぽいので、データタイプによって違う矢印表示にしたい
            ・メイン表示のところ、collapseできるようにする
                ・単なるdetailsタグでもいいかも。むしろ勝手にプレフィクスのあれついてくれて助かるかも。パフォーマンスも軽いだろうし
                    ・でもマークダウンのセルのプレビューに使っちゃった。まあ同時使用してもいいけどかぶるからどうするかな感はでてきたのでまあ後で考えろ
            ・ツリーのところ、もしかしたらメモ化したら設定画面から戻った時も変わらず表示されてくれるかもしれない気がする。たぶんできる。
            ・github pagesに説明書やDLリンク作る。
            ・元々react-uwp使いたかったんだよね…構想として…だからそれに乗り換えたい　あのざらざらした深海のような色合いが元々のイメージだった
            ・カラムの横幅を変えられるやつを導入したい resizable panel react とか split pane とかググればそれっぽいの出てくる　react-split-paneがシンプルでよい？re-resizableの方が？
                ・paneのリサイズは以下がマージされたら対応したい
                    https://github.com/moritzmhmk/react-split-pane/commit/a330d6da93091e487efd87a2dd19cc41f22907c8
            ・slackみたいにカーソルがエクスプローラー側にある時だけエクスプローラー側にスクロールバー出したい
            ・画面遷移時にプログレスバーを出す
            ・文字を確定させずにsubmitしたらIMEのあれが残るやつ、compositionstart, compositionupdate and compositionendをうまく使ってどうにか対処したい
            ・テーマどうするか問題
            ・disabledされてるUIパーツをタップやホバーした時になぜdisabledされているのかの理由を書いてほしい
            ・リンクをデフォルトブラウザで開く　https://qiita.com/indometacin/items/0a436338165dc8b76ec4#%E3%83%AA%E3%83%B3%E3%82%AF%E3%82%92%E3%83%87%E3%83%95%E3%82%A9%E3%83%AB%E3%83%88%E3%83%96%E3%83%A9%E3%82%A6%E3%82%B6%E3%81%A7%E9%96%8B%E3%81%8F
            ・nativeTheme.shouldUseDarkColors　とかでシステムの設定を反映させるかどうか（余裕出たらやるやつ）
            ・スクロールバーを出すのがそのdivにマウスが乗ったときのみにするのもライブラリあるっぽい
                https://openbase.com/categories/js/recently-updated-react-scroll-bar-libraries?orderBy=RECENTLY_UPDATED&
            ・せっかくだからフォントをウェブっぽくないちゃんとしたのに変えたいところ。いちいちhttpリクエスト発生するわけじゃないしさ。ただし絵文字とかも全対応させたいのでそこらへんちゃんとしてるやつのみかな。
            ・ショートカットキーとか
            ・多言語化（設定画面に言語設定も作る）
            ・ツリーの表示がもっさりしてるから別のライブラリに切り替えるか、または今のツリーのオプションを探す
            ・カラムスペース追加時に一瞬ガクっとなる（高さが限界を超える場合）のをいつか直す
            ・表示設定の順番変更できるようにしたように、セルとかも順番変更できるようにしたらどうか
        ■機能
            ・next.jsだとエラー起きた時に根本的に止まっちゃうから変えるわ。reactに移行
            ・開発時とインストール済みのやつ、同じDB参照するようになってるわ。これdevelopmentのときだけ別のところを参照するようにしないと…。
            ・自動アップデート
                ・ぐぐったらなんかやっぱり公式がいろいろかんたんにやれるよう用意してくれてるっぽい
                    https://www.google.com/search?q=electron+check+for+updates&oq=electron+check+for+updates&aqs=chrome..69i57.3909j0j4&sourceid=chrome&ie=UTF-8
                    https://soramugi.wordpress.com/2019/01/28/electron-builder%E3%81%A7%E8%87%AA%E5%8B%95%E3%82%A2%E3%83%83%E3%83%97%E3%83%87%E3%83%BC%E3%83%88%E3%81%AB%E5%AF%BE%E5%BF%9C/
                ・ついでにメニューバーのcheck for updatesも作って
                ・というか再インストールした時にデータが残るのかも確認したい
            ・メニューバーのどこかにCheck for updatesを作る
            ・パフォーマンス問題は、最終的にはファイルDBじゃなく、ローカルに立てたDBMS（MySQLでもMongoDBでも、良さげなやつ選んだもの）を使えるようにして解消したい。
                ・キャッシュ表示設定を開いた時にその表示設定のキャッシュをそのDBMSから読み込む形（初期表示時にキャッシュを生成する。2回目からはそのキャッシュを読み込む。カラムスペースやリレーションに、その表示設定に関わる変更があったらキャッシュを消す）
                ・今はそのタブを開いた時にキャッシュがどうとかやってなくて内部で全部回してコンポーネント作ってるけど、それをキャッシュする＆キャッシュがあったらそこから再生する（いちいち全探索とか不要にする）ということをしたい。そうすればある程度の規模のデータにも耐えられるものになるはず。
            ・設定画面に開閉で開けるdangerゾーン作る。（DB初期化とか。）
            ・中央ペインとか無限スクロール入れる
                ・ただこれ、dataLength的な項目を埋めないといけないならちょっときつみが出てくるな…それの値を出せる別の手を考えるか、無限スクロールの代償として事前にその値を出す計算を事前に挟むかのどちらかかな
                ・補足ペインなら可能かな…？
            ・コンテキストメニューでカット、コピー、ペースト　https://qiita.com/indometacin/items/0a436338165dc8b76ec4#%E3%82%B3%E3%83%B3%E3%83%86%E3%82%AD%E3%82%B9%E3%83%88%E3%83%A1%E3%83%8B%E3%83%A5%E3%83%BC%E3%81%A7%E3%82%AB%E3%83%83%E3%83%88%E3%82%B3%E3%83%94%E3%83%BC%E3%83%9A%E3%83%BC%E3%82%B9%E3%83%88
            ・各種モデルのAPI、駄目なのに例外も出ないし戻値も無い感じだと成功しましたって出るから紛らわしいのでそこらへんのモデルのAPIどうするか考える。
                ・再帰してるから変に例外出すと止まっちゃって面倒だから例外出せないんだよな気軽に…。戻値方式でやるか…でもどう統一するか…
                ・これはテスト実装と同時でいい気がする
            ・大量データの性能テスト、UI崩れのテストをする。めんどいから動作確認すらしてない。
                ・「これは駄目だな。カス」ってなったらアーキテクチャごと変えるのも全然考える。なんせ元々自分がほしいものだから諦められない
            ・最初DB作る時、もうドキュメント配下に「Lace」というディレクトリがある場合そこにデータ置きにいくようになってるので、そこでいいか確認したほうがいいかも。または(2)をつけるとか
            ・UUIDv4じゃなく、日時ありのやつにする。基本絶対かぶらないやつ。またはもうUUIDv4の後ろにタイムスタンプ追記でもする。不安なので。
            ・カラムやカラムスペースを消したら、紐付いてるファイルも消す。そもそもセル消してもファイル消す。
                ・ただしそれはウィンドウを閉じる時とか次回開く時とかでいい。または明示的にクリーンアップのメニューを用意する。結果整合性的な。または関連ファイルを一気に削除しちゃう
				・これ逆に一緒に消しちゃうと、トランザクションでは戻せないから、やっぱり同時にやらずにクリーンアップ的なメニューを用意するのがいいと思う。たぶんこれ普通のwebアプリでも同じことすると思う、バッチ的な。知らんけど。
					・ただ、それなら「deleted_columnspaces」的なテーブルに入れておいてそこをピンポイントで走査するようにしないと全体を走査するのは処理効率下がるわ。でもそうなると大変なのでそこまでやるのはバージョンアップ対応でいいかも。クリーンアップ自体は最初から用意したい。
				・このクリーンアップは、設定画面に「DB容量最適化」的な項目を用意して、その説明になんでこの項目があるのか書いて、「最適化を行う」ボタンを用意すればいい。一応クリックしたら確認ウィンドウ出してOKなら行う。
                ・これ、「deleted_cells」的なテーブルのようなものを用意して置きたいところ。論理削除の仕組み作ってないから、削除済みテーブル作っておく。
                    ・で、セルを配列で保持しておいて、ファイル系のセルならばデータも削除する
                ・ただこれ、sqliteに移行してからやらないと全部無駄になるな…
            ・一応過去のDBはコピーして残しておくこと（設定でどんくらい残すか決められるようにする）
            ・「新しいプロジェクト」「既存のプロジェクト」みたいに読み込めるようにしたいところ…
            ・ctrl + zである程度戻す機能がほしい。たぶん普通にcolumnSpacesの履歴を30個くらい前まで残しておけばいいだけなので後からでも実装できる。というかこの機能無いと怖くて使えない。
            ・ファイルシステムってゴミ箱から復元できるから安心感あるわけだし、戻る機能やバックアップがデフォで無いと使おうと絶対思えない。
            ・トランザクションとりあえず作ったけど、必要なファイルだけロックするようにいつか変えたい。パフォーマンスのため。
            ・ドメインイベントを作るか考える。やり方的にはとりあえずかんたんにstaticフィールドに配列でオブザーバー達のクラス名とメソッド名を入れて、それを特定タイミングで自動newして発火するようにする感じでいいのかなと思う。いや、staticならnewもいらないし。
                ・でもこれ、重くならないかな？うーん。例えば末端のColumnの削除系メソッドにドメインイベントを仕込んだら、カラムが消されることなんて大量にあるじゃん。それを毎度発火するより、もっと上のColumnSpaceあたりで発火したいところだよね。
                    ・それは単に選択の問題かな。となるとむしろ今各種メソッドをColumnSpaces起点にやってるからそこにつっこめばいいかな。
                ・あとこれは各種メソッドをリファクタリングした後でやりたい。
            ・いろいろログを入れたい（特にエラーログ）。そうなるとドメインバリデーションの例外はスルーするようにしないといけないな。自前のを作るか。
                ・それに伴って、普通起こらないはずの例外と、機能的に使ってる例外達をできれば分けたいのかも。知らんけど
                    ・前者は「クラッシュ」と判定して、それが起こる前のDBを完全にバックアップし、一度アプリケーションを使用不能にする。なぜならそれ以上データ壊すの防ぎたいから。
                        ・で、そのクラッシュは自分のサーバに自動送信させたい。DBとしてfirebaseの無料枠使おうかな…？うーん権限判定とかできるかな。
                            ・もちろんその情報送信するかどうかはユーザーに許可取って設定させる。
                    ・後者は普通にアプリケーション内のgotoみたいな用途で使いたい。
                    ・後者の方は自前の例外の型を作ってそれ使えば良いと思う。それだけを機能的な例外として認識し、その他はクラッシュとして扱うかな…？
            ・カラムスペースのリネーム
            ・自動テストを入れてリファクタしやすくする
            ・カラム消したらそれにまつわる表示設定も消されるけど、いずれ消されないようにしたい。今はとりあえず削除で
            ・CSV取り込み、出力の機能がほしい（セルのリレーションについてはidで紐付けてもらう感じで。で、同じカラムにリレーション作ってたりしたらエラーとするなどはしたい。ただこれそれなりに大変そう）
                ・これ、このアプリケーション専用のデータ構造から一般的なデータ構造で関連データを見れるようにしたい要望あるだろうからあるとよいと思う
            ・ダークモード、ライトモード、しゃれおつモードを用意する（最終的にはユーザーが自分で設定できるようにする）
            ・v2を作る時、v1からexportできるようにしたい（これ、csvエクスポートとcsvインポートでまかなえるかも）
            ・画面サイズを変更できる（ミニプレイヤーモード、普通モード）
                https://www.it-swarm-ja.tech/ja/electron/electron%E3%81%A7%E3%82%A6%E3%82%A3%E3%83%B3%E3%83%89%E3%82%A6%E3%82%B5%E3%82%A4%E3%82%BA%E3%82%92%E5%A4%89%E6%9B%B4%E3%81%99%E3%82%8B/833870529/
        ■ソース
            ・モデルのミュータブル、イミュータブルどうするか問題　https://twitter.com/masuda220/status/1392531139756056577
            ・カラムのソート処理、それ用のコンポーネントに任せたほうがよかったかも…（探してもどれも惜しくて、優先度低い）
            ・正規化されたDBと表示用JSONを分けるのもあり
            ・ファイルに触るのはメインプロセス側だけにしたほうがいいかもしれない…　https://zenn.dev/forest1040/articles/7f6794d8651fd4
            ・「remote」が非推奨になってるので使わないコードに変更する。いや、できるならば。
            ・モーダルが連なると、コールバックをコントローラーから持ってくるかモーダル内で作るかの判断が出てくるけど、これどうするか問題ある。
                ・モーダル内はモーダル内でコントローラー作らずにやっていい気がする。
                ・それか、モーダルを1画面を換算し、一つにつき一つコントローラーを作るなど。多分こっちのほうがいい気がする。コントローラーにも大本のコントローラーと末端のコントローラーあって責務分けになるし。
            ・さすがに読み込み時や書き出し時に無駄なので、カラムスペースごとにdbファイルを分けたいところ…でも階層立ってるからな…
                ・別カラムスペースと連動する方式を作りたい場合、その対象カラムスペースのDBを依存先として別途読み込む方式にする（つまり、カラムスペースのjsonのところに依存カラムスペースUUIDの配列的なものを用意して、そこにあるのも読み込むなど）

メモーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー
    ＜概念＞
        カラムスペースス         //複数のカラムスペースをまとめるオブジェクト
        カラムスペース           //全カラムをまとめるオブジェクト
        カラム                  //カラム
        セル                    //カラムの中のセル
        リレイテッドセル         //セルに関連づけられたセル

    ＜CustomListは廃止＞
        ・CustomListは無理だ。せっかく考えたけどたぶん無理だ。以下のような表示でしょ？カラム多くてリレーション作れるには探索コストがすごいことになると思う（キャッシュするならまだしも、まだ無理だし）。
            こういう良さに紐づく以下の様な表示
                アーティスト名「曲名」　詳細の良さ説明
        ・よってCustomListは廃止。似たことやりたいならマークダウンで似たことできるはずだからそっちでやってほしい。
        ・消したときのコミット履歴です。いつか困ったら以下参照。
            https://github.com/lainNao/Lace/commit/4c45132ad6ae6411bba5ab03c8dc50e15455a0cf
        ・で以下が新しくしたときのコミット履歴
            https://github.com/lainNao/Lace/commit/63e76cf2a00dc512ee8abec6b0a221ebb53035bc

    ＜ファイルのゴミ箱について＞
        ・まず、セル、カラム、カラムスペースを削除したら、その配下のファイル系セルのファイルをゴミ箱配下にコピーする（パスの構造はfile_datasと同じ）
        ・で、設定画面にて「ゴミ箱にあるファイルと、それに対応する元ファイルを削除する」設定を用意して、それ実行で「ゴミ箱」かつ「元のfile_datas」フォルダから削除させる
            ・処理的には、ゴミ箱にある「カラムスペースid/カラムid/ファイル名」を走査し、元フォルダの対応するやつを消していく感じ
        ・現状それでいい。手動で消さないようにお願いしたほうがいいな。じゃないと元フォルダにゴミが残る。

    ＜設定画面＞
        ・global_settings.jsonをいじるとする。設定画面は単純にラベルとinputのテーブルにしてCRUDするだけの見た目でとりあえずいいかな
            ■いじらせないけど存在するキー
                majorVersion: メジャーバージョン番号         //メジャーバージョンが違った時、マイグレーションする用に使う（これはユーザーには更新させない）。メジャーバージョン変わってもDBの構造変わらないならマイグレーションは不要
            ■いじれるキー
                autoReport: 真偽値                          //起きちゃいけない例外がキャッチされた時に自動でサーバーに情報を送るか。いらんかなこんなの。うーんまあ考えておく
        ・GlobalSettingsモデル、一応キーに型つけられるかも

    ＜音声データ、基本的には再生したら再生中のやつは一時停止したい＞
        ・音声セル管理モーダルでは実装したので他のところでも基本的にやること

    ＜リレーション、カラムスペースの削除に追従する必要あるので留意＞
       ・例えば以下はリレーションも適宜削除している
            removeColumnSpaceUsecase
            removeColumnUsecase
        ・カラムスペースを削除する時はカラムスペースごとリレーション削除すればいいので楽
        ・カラムを削除する時はtoとfromで別の削除することになるが、removeRelationOfColumnを呼べばよいようにした
        ・セルを削除する時はまた別途必要になってくるので、その時やる
        ・これ、ドメインイベントで対応しても良かったのかなと思う。頭が追いつかなかったけど。書き換えるなら書き換えて。

    ＜RelatedCells登録時の留意＞
        ・いずれのカラム両方にもデータ入れる必要ある（Aカラムのセル1とBカラムのセル2を関連付けた時、Aカラムのセル1の方にもBカラムのセル2の方にもRelatedCellに登録する必要ある。でないとたぶん表示時に計算量が増えすぎる）

    ＜大まかな表示のイメージ＞
        以下の3階層が基本的な考え
        ―――――――――――――――――――――――――――――――
        ・ソート列
            ・メイン表示列
                ・メイン表示列が持つ関連カラムと紐づくセル達
        ―――――――――――――――――――――――――――――――
        ソート列は複数指定可能

    ＜Boolean、Select、Radioとかの複数の値を取りうるカラムは、あってもいいけど消すことにした＞
        ・なぜなら同じことはテキストカラムで全部できるから
        ・Boolean、Select、Radioとかは要するに「セルが一つ」で、関連づけたそのカラムのその一つのセルに対して、関連づけた側のセルの方がその選択値を保持する必要あるんだよね。だからまずその点で一個複雑性が出る
        ・で、例えばselectって「複数の中からいずれかを選択」ってことだけど、それを一つだけ選択なのかcomboboxみたいに複数選択なのかとか考えてたら「そもそもそれってテキストカラムにして一つまたは複数関連づけてもらえばいいやつなんじゃないの？」と気づいてしまった
        ・複雑性が出ても本質的ならばいいんだけど、今回に関してはこれをそのままにしておくとそもそも想定していたデータ構造じゃなくてなんか二重のメタ構造ができてしまうから、それは微妙かなと思った
        ・代わりに、カラムごとに「表示タイプ」みたいなものを持たせて、表示する時に「タグ風に表示」「ラジオボタン的に表示」「セレクトボックス風に表示」とかできるようにしたらいいのかなとは思う

    ＜コード進行カラムの構想＞
        ・「コード進行」（＋「の断片」かな）カラムとか作れるようにして、それは「4M-3m7」とか登録したら「4M-3m」とか「4M6-3m9」とかも設定で非ケースセンシティブな検索もできるような感じのこともしたいところ…　後でコード進行単位でも検索したいしね。
            ・そうなるとソート順ペインは「1」から順になるだろうし、かつその右側のサブソート順はどうなるんだろう？選べるようにしたいよね（7thとM7とかテンションでも分けたいし、かと言って始まりだけじゃなく「4M7-3m7」と「4-3m」も同列に扱いたいし…）
                ・これはどうしようか…まあこれは出来終わってから追加でもいいんだけどシンプルにほしいところ…
        ・コード進行カラムは、「コード進行＋補足説明」にしたほうがいい。でコード進行自体は空欄でよいとしたほうがよい（具体的なコード進行の番号よりもセクションの流れが大事なのもあるので）

    ＜リズム表記カラムの構想＞
        ・コード進行カラムも作るならリズム表記のカラムも作る（○と●と|で表現してたやつ）

    ＜音楽ファイルや動画ファイルは切り抜きをして取り込みができる機能の構想＞
        ・動画ファイルやサウンドファイルは取り込む時に秒数～秒数の指定をして一部だけ取り込みとか簡単にできればよりよい

    ＜セルのポリモーフィズムについて＞
        ・要するにenumをキーに出し分けてくれるファクトリーを作ればいいだけ
        ・インスタンスのファクトリー、ビューのファクトリー、表示文字列のファクトリーをそれぞれ、ポリモーフィズムしたいやつの共有のEnumをキーにして作ればいい
        ・そのため、他のポリモーフィズムしたいところも同じく同じEnumをキーに各層でのファクトリーを作ればいいだけ
            ・別にファクトリーはクラス化する必要はないけど、クラスにまとめてしまってもいいかもしれない。

    ＜「～s」類のモデルはIDを持たない単なるファーストクラスコレクションなので適当にミュータブルにしている＞
        ・既にしていたメソッドをイミュータブルにする手間も感じた
        ・ただまあ必要ならどうにかすることも考える

    ＜表示/非表示フラグのuseState管理だとコスト高そうな部分は、hiddenクラスの削除/追加でやりくりしている＞
        ・はい

    ＜簡単なウィンドウの状態保存にはlocalStorageを使っている＞
        ・一応repository通したほうが良いかな…ソース的に…
        ・ここは後に必要ならば

    ＜コンテキストメニューやダイアログにおいてremoteを使っている＞
        ・コンテキストメニュークリックで動的にdialog出してその結果を受け取りたいんだけど、それがremote使わないと現状やり方わからなかったから。
            ・一応単純なことしかしないコンテキストメニューを出すのはメインプロセスのみでできるけど
        ・ただ「remote」はAPIとして廃止されてしまっているっぽいので、別のremoteのユーザーランドのやつとかに一応移行しておく必要がある。ただ試したけどうまくいかなかったのでまた…
            →いやこれ、invokeでできそう。
                ・invokeでメインプロセスに作ったイベントハンドラを叩く。
                ・そのイベントハンドラ内でダイアログを開かせる。ダイアログの表示文字列はレンダラープロセスから送信できるはず
                ・ダイアログの戻値はメインプロセスで取得し、取得したらメインプロセスからレンダラープロセスへsendする（それができるイベントの仕組みがあるはず）
                ・でそのsendされたのをレンダラープロセスに作ったイベントハンドラで受け取る（そのイベントハンドラはrecoilがアクセスできる範囲で作られる必要があるけどたぶんできる）

                    レンダラ→　メインでダイアログ開く
                                ↓
                    レンダラ  ←ダイアログの戻値
                    ↓
                    戻値によってrecoilの処理をする

                ・なんと面倒な…
        ・だからまあ今の所放置で


                ・「実際表示する時に未生成なら生成する＆今表示してるのに変更加えたらリアルタイムで再生成する」

データ構造ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー
    ＜カラムスペース集約＞（カラムスペースやその配下のセルやカラムなどを保持）
        [
            {
                id: UUID,                   //カラムスペースのUUID
                name: text,                    //カラムスペース名
                columns: {},
                childColumnSpaces: [           //子カラムスペース達
                    {
                        id: UUID,                      //id
                        name: text,                    //カラムスペース名
                        columns: [                     //カラムの全データ
                            {
                                id: UUID,                //カラムのUUID
                                name: string,            //カラム名
                                type: enum,              //カラムのタイプ
                                cells: [                 //自カラムが持つデータ達
                                    各種データ             //自カラムデータのUUIDとデータ本体（実データの形式は、typeのenumによって変わる）
                                    ...

                                    /*file類（Sound、Video、Image）の場合*/（音楽はアーティスト名もいるかと思ったけど、崩れるから辞めた。自分は不要。その代わり随所で楽に試聴できるようにしたいところではある）
                                    {
                                        name: text,              //メディアのファイル名
                                        dispname: text,          //表示用の別名
                                        basename: text,          //ファイル名（拡張子あり）
                                        extname: text,           //拡張子
                                        path: text,              //メディアへのpath
                                    }

                                    /*Textの場合*/
                                    {
                                        text: string,
                                    }

                                    /*Markdownの場合*/
                                    {
                                        title: string,
                                        text: string,
                                    }
                                ],
                            },
                            ...
                        ]
                        childColumnSpaces: [],      //columnsにデータがある場合、ここが空である必要がある（ちょっと汚い設計な雰囲気感じてるけどもう無理、。実装的には不整合は防げる気はしてるから）
                    },
                    ...
                ]
            },
            ...
        ]

    ＜関連セル集約＞（ルートだけモデル化し、その他はしてない…。がんばって）
        // RelatedCells
        {
            // RelatedCellsColumnSpaceIndicator
            カラムスペースのUUID: {

                // RelatedCellsColumnIndicator
                カラムのUUID: {

                    // RelatedCellsCellIndicator
                    //このセルの関連セル達を保存　（留意：関連元セルには「カラムID」の情報は持たない。なぜならカラムスペース直下にキーを作ればカラムからたどる不要だから）
                    セルのUUID: {

                        // RelatedCellsTargetColumnIndicator
                        // そのセルはこのカラムIDのこのセル達と関連している
                        カラムID: [セルID, セルID,...],
                        ...
                    },
                    ..

                }
                ...

            },
            ...
        }

    ＜表示形式集約＞（ソート形式や右ペインの表示形式を保持する）

        // DisplaySettings
        {
            // DisplaySettings.children
            // カラムスペースごとの表示形式の保存
            カラムスペースのUUID: [

                // DisplaySetting
                {
                    // 表示形式ID
                    id: UUID,

                    // 表示設定名
                    name: "フレーズ別要素、とかの名前",

                    //ソートに使うカラム（降順昇順とかのサブパターンもあるだろうけどどうする…？後で…）
                    sortColumns: [カラムID, カラムID, ... ],

                    // メイン表示する中央カラム
                    mainColumn: カラムID,

                    // 関連セル達の表示形式（以下要素にはIDが無いけど、DisplaySetting.idとcolumnIdの複合キーでいけると思うけどどうなんだろう、駄目かな。一時的にそうやっちゃってもいいかな？いや、これはエンティティだと思うのでそもそもIDもたせるべきだった）
                    relatedCellsDisplaySettings: [
                        //この層を「relatedCellsDisplaySetting」とする。
                        {
                            columnId: カラムID,
                            direction: RelatedCellDisplayDirection,  //縦、横のみのEnumを新規で作る。（ちなみに横だとdetailsタグが使えないはず（改行されてしまう）のでクリックでモーダルで詳細開くか、onmouseでツールチップ的に表示するしかないかな）

                            //以下はHorizontalの場合のみ
                            hListDisplayType: HListDisplayType,  //「タグ」「プレーン」の二種。新しくEnum作る。
                            hListSeparator: 任意の文字列,         //セパレータ（タグの場合は基本的には空欄にしてもらえればいいイメージでいいやいろいろ制御分岐するの面倒なので。）
                        },
                        ... // これを残りカラム（ソートカラムやメインカラム以外のもの）で「+」で追加させる。カラム増やした時に新たに追加できるように。
                    ]

                },
                ...

            ],
            ...
        }

    ＜グローバル設定集約＞
        {
            // 初めての起動などで、まだ初期設定をしてないか（各種DBの自動作成など行う。いやDBの自動作成はファイルのあるなしで判定したほうがよさそう）
            "hasInitialized": 真偽値,

            //
        }

    ＜ファイル＞
        ■ファイル
            データフォルダパス/file_datas/カラムスペースID/カラムID/ファイル名.拡張子
        ■ファイルのゴミ箱
            データフォルダパス/file_datas_dust_box/カラムスペースID/カラムID/ファイル名.拡張子

サンプルデーターーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー
    ＜＞
    ＜＞
    ＜display_settings.json＞
        {
            "asdf": [
                {
                    "id": "UUID",
                    "name": "フレーズ別要素、とかの名前",
                    "sortColumns": [111,222],
                    "mainColumn": "3333",

                    "relatedCellsDisplaySettings": [
                        {
                            "columnId": 123123,
                            "direction": "Vertical",
                            "vListPrefix": "Empty"
                        },
                        {
                            "columnId": 234234,
                            "direction": "Horizontal",
                            "hListDisplayType": "Tag",
                            "hListSeparator": ""
                        }

                    ]
                }
            ]
        }


