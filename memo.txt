ルールーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー
    ＜ブランチ＞
        main            //リリース用
        develop         //開発用
        feature/～      //機能用
        feature/any     //機能用（なんでもあり）

    ＜コミット＞
        ・なにもない時は「git commit -m "-"」でよい

    ＜ソース＞
        ・現状自動テストは無しの設計で。でも最終的には作りたい

TODOーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー
    ＜重要（優先度高いorクリティカル）＞
        ■表示形式はカラムスペースごとに保存かつ選択できるようにする
            ・これは忘れないようにしたい
            ・UI上では、カラムスペースを右クリのメニューにそれっぽい項目を追加したり、右側の画面の上あたりでセレクトボックスかリンクとか作って遷移できるようにしたり

        ■たぶん最初フォルダ作ってないとエラーになるから、カラムスペースやカラムのフォルダは無いなら自動生成するようにすること
            はい

        ■データに変更起こしたらサービスからリポジトリにいちいち保存かけていってたけどこれuseEffectまたはRecoilのatomのセッター部分でDBへの保存処理書けばそれらのコード全部いらなくなるかもしれない…
            ・バックエンドの考え方よりも楽できる部分があるかもしれない…
            ・これ実現したらアーキテクチャとしてまとめたいからメモっといて…

        ■そもそもlocalStorageとatomで保存してるやつ、atomのセッター部分にlocalStorageへの保存も書いちゃえばいいのでは…
            ・はい

        ■データ消えないようにすること
            ・このアプリケーションは無慈悲にデータが突然消えるので、コアのAPIは本当によくテストされておく必要があると思う
                ・例えば変な操作をしてリポジトリに投げて保存が失敗するとDBまるごと消える？初期化される。（ソート順で無いインデックスを指定したらそうなった）。これはそうならないようにする必要がある。
            ・コアのAPI自体は正しくても変な構造のデータを送り込んだら消えるとかありそうなのでそこも防ぐ必要がある
            ・あとバックアップもちゃんと取るようにしたい

        ■編集履歴機能
            ・ctrl + zである程度戻す機能がほしい。たぶん普通にcolumnSpacesの履歴を30個くらい前まで残しておけばいいだけなので後からでも実装できる。というかこの機能無いと怖くて使えない。
            ・ファイルシステムってゴミ箱から復元できるから安心感あるわけだし、戻る機能やバックアップがデフォで無いと使おうと絶対思えない。

        ■保存場所カスタマイズ機能
            ・ひとまずdocument配下にしてるけど

        ■インストール不要化
            ・asarとかでインストール不要な形にパッケージングしたい

        ■vscodeみたいに各ペインの幅を変えられるようにしたい
            ・はい

        ■集約（というかファイル）が増えたので、トランザクションがほしくなった
            ・単純に処理ごとに新しいファイルを作成し、全処理が成功したら処理前のファイルを消し、途中の処理が失敗したら新しいファイルを消せばいいけど、コスト高い
            ・まあここらへんは後で…（後でばかりなのが辛いけどこれが現実だから、それで後で苦労するのならば力不足なのがリアルなのだから受け入れるしかない。ただ、実際ここは後回しできるとは考えてる）

    ＜他（リリース前には必ず）＞
        ・特定サイズ未満へのリサイズは不可にする
        ・フォーム登録時とか、例外とか出たらフォーム消えるだけで分からないから、「errorMessages」的なのをuseStateで保持して、それがある時はエラー表示オーバーレイをnext.jsのデフォよりも軽い感じで出すようにしたほうがいいと思う。まあこれは後でまとめてやることが可能だと思うからあとで
        ・ユースケースのファイル、「UseCase」になってるけどだるいから「Usecase」にして…
        ・自動テスト書いても良いかも…再帰の部分が特にバグったら面倒なので
        ・ファイルに触るのはメインプロセス側だけにしたほうがいいかもしれない…　https://zenn.dev/forest1040/articles/7f6794d8651fd4
        ・「remote」が非推奨になってるので使わないコードに変更する。いや、できるならば。
        ・「handle～」じゃなくて普通に「on～」に変えたほうがわかりやすいのでは
        ・モデルのミュータブル、イミュータブルどうするか問題　https://twitter.com/masuda220/status/1392531139756056577
        ・ロゴの設定
        ・なぜか横スクロールバーが太いので直す
        ・テーマどうするか問題
        ・nativeTheme.shouldUseDarkColors　とかでシステムの設定を反映させるかどうか（余裕出たらやるやつ）
        ・ウィンドウの横幅を縮めた時に縦スクロールバーが出てしまう現象直す
        ・多言語化すること
        ・UUIDv4じゃなく、日時ありのやつにする。基本絶対かぶらないやつ。またはもうUUIDv4の後ろにタイムスタンプ追記でもする。不安なので。
        ・ダークモード、ライトモード、しゃれおつモードを用意する（最終的にはユーザーが自分で設定できるようにする）
        ・最終的にはいちいち毎操作ごとにファイルに保存するのはやめて、vscodeみたいに保留しておく。
            ・ただし、ファイルアップロードをしたら必ず同期する必要がある（それはvscodeでも同じはず）。テキストでの変化のみは保存保留が可能
        ・buildすると、DBやユーザデータ置き場のフォルダとか消えるので、DBは「無い場合は作る」という動作をするようにすること。
            ・ビルドするとパスが変わったりすることがありそうなので、やっぱり絶対パスで試す。絶対パスでやると逆にうまくいかなくなる場合もありそうなので、試しながらやる。
        ・一応過去のDBはコピーして残しておくこと（設定でどんくらい残すか決められるようにする）
        ・再生ボタンはreact-uwpとかを使う？
        ・v2を作る時、v1からexportできるようにしたい
        ・さすがに読み込み時や書き出し時に無駄なので、カラムスペースごとにdbファイルを分けたいところ…でも階層立ってるからな…
            ・別カラムスペースと連動する方式を作りたい場合、その対象カラムスペースのDBを依存先として別途読み込む方式にする（つまり、カラムスペースのjsonのところに依存カラムスペースUUIDの配列的なものを用意して、そこにあるのも読み込むなど）
		・アップデートチェック機能もあるといい
        ・画面サイズを変更できる（ミニプレイヤーモード、普通モード）
            https://www.it-swarm-ja.tech/ja/electron/electron%E3%81%A7%E3%82%A6%E3%82%A3%E3%83%B3%E3%83%89%E3%82%A6%E3%82%B5%E3%82%A4%E3%82%BA%E3%82%92%E5%A4%89%E6%9B%B4%E3%81%99%E3%82%8B/833870529/
        ・画面遷移時にプログレスバーを出す



メモーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー
    ＜概念＞
        カラムスペースス         //複数のカラムスペースをまとめるオブジェクト
        カラムスペース           //全カラムをまとめるオブジェクト
        カラム                  //カラム
        セル                    //カラムの中のセル
        リレイテッドセル         //セルに関連づけられたセル

    ＜RelatedCells登録時の留意＞
        ・いずれのカラム両方にもデータ入れる必要ある（Aカラムのセル1とBカラムのセル2を関連付けた時、Aカラムのセル1の方にもBカラムのセル2の方にもRelatedCellに登録する必要ある。でないとたぶん表示時に計算量が増えすぎる）

    ＜大まかな表示のイメージ＞
        以下の3階層が基本的な考え
        ―――――――――――――――――――――――――――――――
        ・ソート列
            ・メイン表示列
                ・メイン表示列が持つ関連カラムと紐づくセル達
        ―――――――――――――――――――――――――――――――

    ＜Boolean、Select、Radioとかの複数の値を取りうるカラムは、あってもいいけど消すことにした＞
        ・なぜなら同じことはテキストカラムで全部できるから
        ・Boolean、Select、Radioとかは要するに「セルが一つ」で、関連づけたそのカラムのその一つのセルに対して、関連づけた側のセルの方がその選択値を保持する必要あるんだよね。だからまずその点で一個複雑性が出る
        ・で、例えばselectって「複数の中からいずれかを選択」ってことだけど、それを一つだけ選択なのかcomboboxみたいに複数選択なのかとか考えてたら「そもそもそれってテキストカラムにして一つまたは複数関連づけてもらえばいいやつなんじゃないの？」と気づいてしまった
        ・複雑性が出ても本質的ならばいいんだけど、今回に関してはこれをそのままにしておくとそもそも想定していたデータ構造じゃなくてなんか二重のメタ構造ができてしまうから、それは微妙かなと思った
        ・代わりに、カラムごとに「表示タイプ」みたいなものを持たせて、表示する時に「タグ風に表示」「ラジオボタン的に表示」「セレクトボックス風に表示」とかできるようにしたらいいのかなとは思う

    ＜コード進行カラムの構想＞
        ・「コード進行」（＋「の断片」かな）カラムとか作れるようにして、それは「4M-3m7」とか登録したら「4M-3m」とか「4M6-3m9」とかも設定で非ケースセンシティブな検索もできるような感じのこともしたいところ…　後でコード進行単位でも検索したいしね。
            ・そうなるとソート順ペインは「1」から順になるだろうし、かつその右側のサブソート順はどうなるんだろう？選べるようにしたいよね（7thとM7とかテンションでも分けたいし、かと言って始まりだけじゃなく「4M7-3m7」と「4-3m」も同列に扱いたいし…）
                ・これはどうしようか…まあこれは出来終わってから追加でもいいんだけどシンプルにほしいところ…
        ・コード進行カラムは、「コード進行＋補足説明」にしたほうがいい。でコード進行自体は空欄でよいとしたほうがよい（具体的なコード進行の番号よりもセクションの流れが大事なのもあるので）

    ＜リズム表記カラムの構想＞
        ・コード進行カラムも作るならリズム表記のカラムも作る（○と●と|で表現してたやつ）

    ＜音楽ファイルや動画ファイルは切り抜きをして取り込みができる機能の構想＞
        ・動画ファイルやサウンドファイルは取り込む時に秒数～秒数の指定をして一部だけ取り込みとか簡単にできればよりよい

    ＜セルのポリモーフィズムについて＞
        ・要するにファクトリーを作ればいいだけ
        ・インスタンスのファクトリー、ビューのファクトリー、表示文字列のファクトリーをそれぞれ、ポリモーフィズムしたいやつの共有のEnumをキーにして作ればいい
        ・そのため、他のポリモーフィズムしたいところも同じく同じEnumをキーに各層でのファクトリーを作ればいいだけ
            ・別にファクトリーはクラス化する必要はないけど、クラスにまとめてしまってもいいかもしれない。

    ＜「～s」類のモデルはIDを持たない単なるファーストクラスコレクションなので適当にミュータブルにしている＞
        ・既にしていたメソッドをイミュータブルにする手間も感じた
        ・ただまあ必要ならどうにかすることも考える

    ＜表示/非表示フラグのuseState管理だとコスト高そうな部分は、hiddenクラスの削除/追加でやりくりしている＞
        ・はい

    ＜簡単なウィンドウの状態保存にはlocalStorageを使っている＞
        ・一応repository通したほうが良いかな…ソース的に…
        ・ここは後に必要ならば

    ＜コンテキストメニューやダイアログにおいてremoteを使っている＞
        ・コンテキストメニュークリックで動的にdialog出してその結果を受け取りたいんだけど、それがremote使わないと現状やり方わからなかったから。
            ・一応単純なことしかしないコンテキストメニューを出すのはメインプロセスのみでできるけど
        ・ただ「remote」はAPIとして廃止されてしまっているっぽいので、別のremoteのユーザーランドのやつとかに一応移行しておく必要がある。ただ試したけどうまくいかなかったのでまた…
            →いやこれ、invokeでできそう。
                ・invokeでメインプロセスに作ったイベントハンドラを叩く。
                ・そのイベントハンドラ内でダイアログを開かせる。ダイアログの表示文字列はレンダラープロセスから送信できるはず
                ・ダイアログの戻値はメインプロセスで取得し、取得したらメインプロセスからレンダラープロセスへsendする（それができるイベントの仕組みがあるはず）
                ・でそのsendされたのをレンダラープロセスに作ったイベントハンドラで受け取る（そのイベントハンドラはrecoilがアクセスできる範囲で作られる必要があるけどたぶんできる）

                    レンダラ→　メインでダイアログ開く
                                ↓
                    レンダラ  ←ダイアログの戻値
                    ↓
                    戻値によってrecoilの処理をする

                ・なんと面倒な…
        ・だからまあ今の所放置で

    ＜データ構造について＞
        ■カラムスペース集約（カラムスペースやその配下のセルやカラムなどを保持）
            [
                {
                    id: UUID,                   //カラムスペースのUUID
                    name: text,                    //カラムスペース名
                    columns: {},
                    childColumnSpaces: [           //子カラムスペース達
                        {
                            id: UUID,                      //id
                            name: text,                    //カラムスペース名
                            columns: [                     //カラムの全データ
                                {
                                    id: UUID,                //カラムのUUID
                                    name: string,            //カラム名
                                    type: enum,              //カラムのタイプ
                                    cells: [                 //自カラムが持つデータ達
                                        各種データ             //自カラムデータのUUIDとデータ本体（実データの形式は、typeのenumによって変わる）
                                        ...

                                        /*file類（Sound、Video、Image）の場合*/
                                        {
                                            name: text,              //メディアのファイル名
                                            basename: text,          //ファイル名（拡張子あり）
                                            extname: text,           //拡張子
                                            path: text,              //メディアへのpath
                                        }

                                        /*Text、Markdownの場合*/
                                        {
                                            text: string,
                                        }
                                    ],
                                },
                                ...
                            ]
                            childColumnSpaces: [],      //columnsにデータがある場合、ここが空である必要がある（ちょっと汚い設計な雰囲気感じてるけどもう無理、。実装的には不整合は防げる気はしてるから）
                        },
                        ...
                    ]
                },
                ...
            ]

        ■関連セル集約
            {
                カラムスペースのUUID: {

                     //このセルの関連セル達を保存
                     セルのUUID: {

                         // 関連セル達を、カラムIDをキーに保存
                         カラムID: [セルID, セルID,...],
                         ...
                     },
                     ...

                },
                ...
            }

        ■表示形式集約（ソート形式や右ペインの表示形式を保持する）
            {
                // カラムスペースごとの表示形式の保存
                カラムスペースのUUID: [

                    {
                        // 表示形式ID
                        id: UUID,

                        // 表示設定名
                        name: "フレーズ別要素、とかの名前",

                        //ソートに使うカラム（降順昇順とかのサブパターンもあるだろうけどどうする…？後で…）
                        sortColumns: [カラムID, カラムID, ... ],

                        // メイン表示する中央カラム
                        mainColumn: カラムID,

                        // 関連セルの表示形式
                        relatedCellsDisplaySettings: [
                            {
                                // 表示形式
                                type: RelatedCellsDisplayType,      //VList（普通の箇条書き）、VListDot（●を頭につける箇条書き）、VListNum（数字を頭につける箇条書き）、HListSeparator（「、」とかで区切る横書き）、HListTag（タグ風の角丸マークで横書き）
                                                                    //CustomList（任意の表示。詳しくは、自分の創作技法集の表示に合わせる感じなのでそっち参照。簡単）

                                // type別の詳細設定。現状CustomListの場合とHListSeparatorの場合だけで、それ以外の場合はnull
                                typeDetails: {

                                    /* HListSeparatorの場合 */
                                    separator: "、とかのセパレータ文字"



                                    /* CustomListの場合 */

                                    // タイトル（CustomListじゃない場合、カラム名がタイトルとして使われる）
                                    title: "曲例、とか",

                                    // カラム達の設定
                                    columns: [
                                        {
                                            columnId: カラムID,

                                            prefix: "つけたい前置文字。nullable",

                                            suffix: "つけたい後置文字。nullable",

                                            // このカラムの前に改行かつインデントを入れるか（何言ってるかわからない場合自分の創作技法集の表示参照）
                                            needBreakLine: 真偽値,

                                        },
                                        ...
                                    ]

                                }

                            },
                            ...
                        ]

                    },
                    ...

                ],
                ...
            }

        ■グローバル設定集約
            {
                // 初めての起動などで、まだ初期設定をしてないか（各種DBの自動作成など行う）
                "hasInitialized": 真偽値,

                //
            }

    ＜後で使うかもしれない、リポジトリにあった旧ファイルアップロードのメソッド達＞

        // async uploadFile(fileObject, targetColumnUUID): Promise<columnSpacesType> {
        //   const filePath = await this.getSavePathWithoutDuplication(fileObject.name, targetColumnUUID);
        //   const realFilePath = this.publicPath + filePath;
        //   const currentcolumnSpaces = await this.readDB();

        //   let newcolumnSpaces = Object.assign({}, currentcolumnSpaces);
        //   // newcolumnSpaces[this.currentColumnSpaceUUID].columns[targetColumnUUID].datas[uuidv4()] = {
        //   //   path: filePath,
        //   //   type: fileObject.type,
        //   //   name: parse(realFilePath).name + parse(realFilePath).ext,
        //   //   childsColumnsDatas: {},    //この時点では空にし、後々セットする時にこの中身は持たせる。なぜならば、ここでファイル取り込みした後にchild_columnsの中の要素が増える可能性があるため。
        //   // };

        //   // エラーハンドリングもする。サービス側で一括でやったほうがいいかも
        //   copyFileSync(fileObject.path, realFilePath)
        //   this.saveFile(newcolumnSpaces);

        //   console.log("DB書き出し完了");
        //   return newcolumnSpaces;
        // }

        // private createColumnSpaceDirectory(columnSpaceName: string): string | void {
        //   // エラーハンドリングもする。サービス側で一括でやったほうがいいかも
        //   if (!existsSync(columnSpaceName)){
        //     mkdirSync(columnSpaceName);
        //   } else {
        //     throw new Error("既に存在しています");
        //   }
        // }



        // private async getCellSaveDirectoryOf(targetColumnUUID: string): Promise<string> {
        //   const userDataPath = await getSaveDirPath();
        //   return path.join(userDataPath, "userdata/column_spaces", targetColumnUUID) + "/";
        // }

        // private getSaveFileName(saveDirectory, fileName, extension) {
        //   for (let i=0; ; i++) {
        //     const path = (i === 0)
        //       ? this.publicPath + saveDirectory + fileName + extension
        //       : this.publicPath + saveDirectory + fileName + `(${i})` + extension

        //     const samePathExists = fs.existsSync(path)
        //     if (samePathExists) {
        //       continue;
        //     }
        //     return path
        //   }
        // }

        // private async getSavePathWithoutDuplication(filenameWithExtension, targetColumnUUID): Promise<string> {
        //   const saveDirectory = await this.getCellSaveDirectoryOf(targetColumnUUID);
        //   const saveFileName = this.getSaveFileName(this.publicPath, path.parse(filenameWithExtension).name, path.parse(filenameWithExtension).ext);
        //   return saveDirectory + saveFileName;
        // }

■サンプルデータ
    ＜＞
    ＜＞
    ＜display_settings.json＞
        {
        "カラムスペースのUUID": [
            {
            "id": "UUID",
            "name": "フレーズ別要素、とかの名前",
            "sortColumns": [111,222],
            "mainColumn": "3333",

            "relatedCellsDisplaySettings": [
                {
                "type": "CustomList",
                "typeDetails": {
                    "title": "曲例、とか",
                    "columns": [
                    {
                        "columnId": "カラムID",
                        "prefix": "つけたい前置文字。nullable",
                        "suffix": "つけたい後置文字。nullable",
                        "needBreakLine": false
                    }
                    ]
                }
                }
            ]
            }
        ]
        }


